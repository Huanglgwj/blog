<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面试题 - 面试时遇到的 | 黄文杰 的博客 ｜ huang Blog</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/blog/blog/favicon.ico">
    <meta name="description" content="个人博客">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/blog/assets/css/0.styles.1a0d8da5.css" as="style"><link rel="preload" href="/blog/assets/js/app.9278b647.js" as="script"><link rel="preload" href="/blog/assets/js/6.b9ade4ff.js" as="script"><link rel="preload" href="/blog/assets/js/13.715791f0.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.24968df8.js"><link rel="prefetch" href="/blog/assets/js/11.2e7fcfa4.js"><link rel="prefetch" href="/blog/assets/js/12.66267855.js"><link rel="prefetch" href="/blog/assets/js/14.539a9f7d.js"><link rel="prefetch" href="/blog/assets/js/2.4c97bbdc.js"><link rel="prefetch" href="/blog/assets/js/3.c2dabf62.js"><link rel="prefetch" href="/blog/assets/js/4.fddc1d5b.js"><link rel="prefetch" href="/blog/assets/js/5.384f7650.js"><link rel="prefetch" href="/blog/assets/js/7.fd9016ab.js"><link rel="prefetch" href="/blog/assets/js/8.f26ae0a1.js"><link rel="prefetch" href="/blog/assets/js/9.429b2cc6.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.1a0d8da5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="global-layout" data-v-7f2e4136><header class="header-container" style="background-size:cover;background-repeat:no-repeat;background-position:center;background-attachment:scroll;background-image:url(/blog/home-bg.jpeg);" data-v-93921ff8 data-v-7f2e4136><nav class="navbar" style="position:absolute;opacity:1;transition:all 0.5s ease-in-out;" data-v-93921ff8><a href="/blog/" class="navbar-link router-link-active">
    黄文杰的博客
  </a> <ul class="navbar-links"><li><a href="/blog/" class="router-link-active">
        HOME
      </a></li><li><a href="/blog/about/">
        ABOUT
      </a></li><li><a href="/blog/tags/">
        TAGS
      </a></li></ul> <div id="nav-icon"><span></span><span></span><span></span></div></nav> <div class="header-title" data-v-93921ff8 data-v-93921ff8><h1 data-v-93921ff8>面试题 - 面试时遇到的</h1> <p data-v-93921ff8></p></div></header> <div class="container" data-v-b3fda33c data-v-7f2e4136><main class="main" style="width:60%;" data-v-b3fda33c><div class="post" data-v-b3fda33c data-v-b3fda33c><article class="main-div"><div class="post-content content content__default"><h2 id="_1、说一下盒子模型"><a href="#_1、说一下盒子模型" class="header-anchor">#</a> 1、说一下盒子模型</h2> <blockquote><p>标准盒模型： 内容区域就是content的所占区域，它的宽 = content的宽，高 = content的高</p></blockquote> <ul><li>在标准盒模型下，修改内边距 padding和边框border会撑大盒子，要注意元素之间的位置</li> <li>设置标准盒模型，<code>box-sizing: content-box</code>，默认值，不用特意去设置</li></ul> <blockquote><p>IE盒模型(怪异盒模型): 内容区域是 content + padding + border，它的宽是三者相加，它的高是三者相加</p></blockquote> <ul><li>在IE盒模型中，修改padding和边框border会向内扩展，故也称内减模式</li> <li>设置IE盒模型 <code>box-sizing: border-box</code></li></ul> <h2 id="_2、说一下-call、apply、bind有什么区别和应用场景"><a href="#_2、说一下-call、apply、bind有什么区别和应用场景" class="header-anchor">#</a> 2、说一下 <code>call</code>、<code>apply</code>、<code>bind</code>有什么区别和应用场景</h2> <ul><li>三者都是用来定义上下文的，也就是修改this的指向</li> <li>call 和 apply 会执行上下文并执行函数，而bind会执行上下文但不会执行函数，并返回新的函数</li> <li>另外的区别是传参</li> <li>call(name, 1,2,3)</li> <li>apply(name, [1,2,3])</li> <li>bind(name,1,2,3)()</li></ul> <h2 id="_3、js的原型和原型链"><a href="#_3、js的原型和原型链" class="header-anchor">#</a> 3、js的原型和原型链</h2> <blockquote><p>原型</p></blockquote> <ul><li>1、每个函数都有一个prototype属性，被称为显性原型</li> <li>2、每个实例对象都有一个 <code>__proto__</code> 属性，称为隐形原型</li> <li>3、每个实例对象的隐形原型 <code>__proto__</code> 属性指向自身构造函数的显性原型 prototype</li> <li>4、每个prototype原型都有一个constructor属性，指向它关联的构造函数</li></ul> <blockquote><p>原型链<br>
获取对象属性时，如果对象自身没有这个属性，那就会去他的原型 <code>__proto__</code>去找，如果找不到，就会找原型的原型，直到最顶层 <code>object.prototype</code>为止，形成的链式关系就叫原型链， Object.prototype对象也有 <code>__proto__</code> 属性值为Null,</p></blockquote> <h2 id="_4、js的数据类型有哪些-以及检测数据类型的方法"><a href="#_4、js的数据类型有哪些-以及检测数据类型的方法" class="header-anchor">#</a> 4、js的数据类型有哪些，以及检测数据类型的方法</h2> <ul><li>数据类型有： 基础类型string,number,undefined,null,boolean 和 引用类型 object,array,function,date</li> <li>检测数据类型方法有:
<ul><li>typeof： 区分基础类型，但不能识别null(会返回object，与二进制转换有关)，可以识别function，但其他引用类型都是object</li> <li>instanceof: 判断两个对象之间是否属于实例关系</li> <li>Object.prototype.toString.call 可以检测所有类型</li></ul></li></ul> <h2 id="_5、display有哪些属性"><a href="#_5、display有哪些属性" class="header-anchor">#</a> 5、display有哪些属性</h2> <ul><li>block: 块状元素</li> <li>inline: 内联元素</li> <li>inline-block: 行内块元素</li> <li>none</li> <li>flex: 弹性布局</li> <li>inline-table: 内联表格</li> <li>table: 块级表格</li> <li>grid: 网格布局</li> <li>inherit: 继承父元素的属性值</li></ul> <h2 id="_6、csrf和xss是什么-如何避免"><a href="#_6、csrf和xss是什么-如何避免" class="header-anchor">#</a> 6、csrf和xss是什么，如何避免</h2> <blockquote><p>xss：跨站脚本攻击， 是一个代码注入攻击，避免方式有</p></blockquote> <ul><li>url参数使用encodeURLComponent方法转义</li> <li>后端做过滤检查</li> <li>对用户输入内容做标签转换</li></ul> <blockquote><p>csrf：跨站请求伪造，避免方式有</p></blockquote> <ul><li>添加验证码</li> <li>使用token</li></ul> <h2 id="_7、let-const-var区别"><a href="#_7、let-const-var区别" class="header-anchor">#</a> 7、let/const/var区别</h2> <ul><li>var是es5提出的，let/const是es6提出的</li> <li>const声明是常量，必须赋值，声明后不可修改，let和var是变量，可修改可不赋值</li> <li>var可以重复声明变量，覆盖前面一个，let和const在同一作用域内不允许重复声明</li> <li>var存在变量提升，const和let不存在变量提升</li> <li>var 不存在块级作用域，是函数作用域，let和const存在块级作用域</li></ul> <h2 id="_8、什么是虚拟dom"><a href="#_8、什么是虚拟dom" class="header-anchor">#</a> 8、什么是虚拟DOM</h2> <p>虚拟DOM是对真实DOM的映射，本质上是一个普通的js对象</p> <h2 id="_9、vue组件的传值方式"><a href="#_9、vue组件的传值方式" class="header-anchor">#</a> 9、vue组件的传值方式</h2> <ul><li>父传子： props</li> <li>子传父： $emit</li> <li>provide 和 inject</li> <li>parent 和 children</li> <li>ref</li> <li>$attrs 和 $ listeners</li> <li>跨组件： event-bus，定义全局事件总线 vue.prototype.$bus = some</li></ul> <h2 id="_10、ajax-和-axios"><a href="#_10、ajax-和-axios" class="header-anchor">#</a> 10、ajax 和 axios</h2> <ul><li>ajax: 是一种技术方案,依赖浏览器提供的 XMLHttpRequest 对象发出 HTTP 请求和接收 HTTP 响应, 实现与服务器的数据交互</li> <li>axios: 是一个基于promise的网络请求库，也是使用XMLHttpRequest进行请求和接受</li></ul> <h2 id="_11、跨域的处理方式"><a href="#_11、跨域的处理方式" class="header-anchor">#</a> 11、跨域的处理方式</h2> <ul><li>利用script标签请求</li> <li>window.postMessage</li> <li>jsonp</li> <li>cors</li> <li>webpack本地代理</li> <li>websocke</li> <li>nginx反向代理</li></ul> <h2 id="_12、localstorage-sessionstorage-cookie-session区别"><a href="#_12、localstorage-sessionstorage-cookie-session区别" class="header-anchor">#</a> 12、localStorage，sessionStorage,cookie,session区别</h2> <ul><li><p>cookie数据始终在同源的http请求中携带，会在浏览器和服务器直接来回传递，而localStorage只存本地</p></li> <li><p>存储大小限制不同，cookie不能超过4k左右，而localStorage和sessionStorage可以到5M</p></li> <li><p>数据有效期不同，sessionStorage仅在的当前窗口关闭前有效，localStorage始终有效，cookie也是所有同源窗口共享的</p></li> <li><p>cookie数据存放在客户的浏览器上，session存储在服务器</p></li></ul> <h2 id="_13、http-状态码都有哪些"><a href="#_13、http-状态码都有哪些" class="header-anchor">#</a> 13、http 状态码都有哪些</h2> <ul><li>200： 客户端请求成功</li> <li>204: 无返回内容</li> <li>400：客户端请求语法错误，服务器无法理解</li> <li>401： 未授权</li> <li>403： 服务器拒绝提供服务</li> <li>404：资源不存在</li> <li>500： 服务器发生不可预期错误</li> <li>503：服务器当前不能处理客户端请求</li></ul> <h2 id="_14、es6有哪些新特性"><a href="#_14、es6有哪些新特性" class="header-anchor">#</a> 14、es6有哪些新特性</h2> <p>let,const,模板字符串，展开运算符，箭头函数，函数参数默认值，解构赋值</p> <h2 id="_15、promise有哪些方法"><a href="#_15、promise有哪些方法" class="header-anchor">#</a> 15、promise有哪些方法</h2> <p>all(全部成功),race(执行最快的),resolve,finally,catch,then</p> <h2 id="_16、vue-watch-和-computed-区别和使用场景"><a href="#_16、vue-watch-和-computed-区别和使用场景" class="header-anchor">#</a> 16、Vue watch 和 computed 区别和使用场景</h2> <ul><li><p>watch 是监听一个值的变化，然后执行对应的回调</p></li> <li><p>watch中的函数不需要调用</p></li> <li><p>watch不支持缓存</p></li> <li><p>watch有两个参数 immediate: 组件加载立即触发，deep: 深度监听</p></li> <li><p>computed 中的函数直接调用</p></li> <li><p>computed中的函数必须return返回</p></li> <li><p>computed 依赖data中的属性，data属性值发生改变的时候，当前函数才会执行</p></li> <li><p>computed中不能对data中的属性进行赋值</p></li> <li><p>computed属性的结果会被缓存，除非依赖的属性发生变化才会重新计算</p></li></ul> <blockquote><p>使用场景</p></blockquote> <ul><li>watch：适合一个数据影响多个数据，例如购物车商品结算</li> <li>computed： 一个数据受多个数据影响，如搜索数据</li></ul> <h2 id="_17、vue3-和-vue2-的区别"><a href="#_17、vue3-和-vue2-的区别" class="header-anchor">#</a> 17、vue3 和 vue2 的区别</h2> <ul><li>1、vue2是使用object.defineProperty对数据进行劫持，结合发布订阅者模式的方式实现的，vue3使用proxy进行代理，可以直接监听对象和数据的变化，不需要遍历每个属性</li> <li>2、根节点不同，vue3组件中支持多个根节点，可以写多个div根标签</li> <li>3、Composition API（组合API）</li> <li>4、 生命周期的变化，vue3没有beforCreate和create，用setup()代替，其他生命周期也换了名字</li> <li>5、diff算法</li> <li>vue2的diff算法是进行虚拟节点对比，并返回一个patch对象，用来存储两个节点不同的地方，最后根据patch记录去局部更新DOM，会比较每一个Vnode,对于一些不参与更新的元素，进行比较是有点消耗性能的</li> <li>vue3的diff算法在初始化的时候会给每个虚拟节点添加一个patchFlags，patchFlags就是优化的标识，只会比较patchFlags发送变化的Vnode进行更新视图，没有变化的元素在渲染时直接复用</li> <li>6、v-if v-for的优先级</li> <li>vue2的v-for优先级大于v-if</li> <li>vue3的v-if优先级大于v-for</li></ul> <h2 id="_18、虚拟-dom-和真实-dom-的区别"><a href="#_18、虚拟-dom-和真实-dom-的区别" class="header-anchor">#</a> 18、虚拟 dom 和真实 dom 的区别</h2> <ul><li>真实DOM是文档对象模型，是一个结构化文本的抽象</li> <li>虚拟DOM是以javascript对象形式存在的对真实DOM的描述</li></ul> <blockquote><p>区别</p></blockquote> <ul><li>虚拟DOM不会进行排版与重绘操作，真实DOM会频繁重排和重绘</li> <li>虚拟DOM的总损耗是 “虚拟DOM的增删改+真实DOM的差异增删改+排版和重绘”，真实DOM的总损耗是“真实DOM的完全增删改+排版和重绘”</li></ul> <h2 id="_19、http和https区别"><a href="#_19、http和https区别" class="header-anchor">#</a> 19、http和https区别</h2> <ul><li>http: 超文本传输协议，运行在TCP之上，指定了客户端可能发送给服务端什么样的消息以及得到什么样的响应</li> <li>https: 是在http的基础上通过传出加密和身份认证保证了传输过程的安全性，在http基础上加入SSL协议</li> <li>SSL：是一个为网络通信提供安全以及数据完整性的一种安全协议，TLS与SSL在传输层与应用层之间对网络连接进行加密</li></ul> <blockquote><p>区别</p></blockquote> <ul><li>传输信息安全性不同，http是明文传输，攻击者截取了传输报文就可直接看到信息，https是通过SSL进行了传输加密</li> <li>连接方式不同：http是无状态的，而https是有SSL+http协议构建的可进行加密传输、身份认证的网络协议</li> <li>端口不同：http协议端口是80，https是443</li> <li>证书申请方式不同：http协议免费申请，https需要ca申请证书，一般需要缴费</li></ul> <h2 id="_20、post和get"><a href="#_20、post和get" class="header-anchor">#</a> 20、post和get</h2> <ul><li>get参数通过URL传递，post放在body</li> <li>get在URL传递的参数有长度限制，post没有</li> <li>get在浏览器回退是无害的，post会再次提交请求</li> <li>get请求会被浏览器主动cache，post不会</li> <li>get会直接暴露在URL，相对不安全</li> <li>get只接受ASCll字符，post没有限制</li> <li>get产生一个TCP数据包，POST产生两个TCP数据包（先发送header后发送data）</li></ul> <h2 id="_21、闭包"><a href="#_21、闭包" class="header-anchor">#</a> 21、闭包</h2> <p>闭包是值有权访问另一个函数作用域中变量的函数</p> <blockquote><p>特性</p></blockquote> <ul><li>函数内嵌套函数</li> <li>内部函数可以引用外层的参数和变量</li> <li>参数和变量不会被垃圾回收机制回收</li></ul> <h2 id="_22、this指向"><a href="#_22、this指向" class="header-anchor">#</a> 22、this指向</h2> <ul><li>this默认指向函数的直接调用者</li> <li>如果有new关键字，this指向new出来的那个对象</li> <li>在事件中，this指向触发这个事件的对象</li> <li>箭头函数指向所在作用域的那个对象</li></ul> <h2 id="_23、事件循环机制"><a href="#_23、事件循环机制" class="header-anchor">#</a> 23、事件循环机制</h2> <ul><li>javascript是单线程执行模式，执行的时候会区分为主线程和任务队列，主线程执行完毕，会从任务队列中读取新的任务放入主线程执行，这个读取过程是循环读取，所以叫事件循环</li> <li>任务队列分为宏任务和微任务，同层次，会先执行微任务，再执行宏任务</li> <li>微任务： promise.then()，process.nextTick()</li> <li>宏任务： setTimeOut(), setInterval()</li></ul> <h2 id="_24、重绘与回流"><a href="#_24、重绘与回流" class="header-anchor">#</a> 24、重绘与回流</h2> <blockquote><p>重绘：当页面中元素的样式发生改变时，并且元素的样式改变不会改变元素在文档中的位置，那么浏览器会将新样式赋予给元素，这个过程叫重绘</p></blockquote> <ul><li>会导致重绘的有：background,visibility,绝对定位位置修改</li></ul> <blockquote><p>回流：当渲染树中的一些元素的结构或者尺寸发送改变，浏览器会重新渲染部分或者全部文档的过程，叫回流</p></blockquote> <ul><li>会导致回流的有：页面初次渲染，窗口大小改变，content文本内容变换，新增删除节点，激活css伪类</li></ul> <blockquote><p>回流的性能消耗比重绘大，回流必定导致重绘，重绘不一定会回流</p></blockquote> <h2 id="_25、输入url发生了什么"><a href="#_25、输入url发生了什么" class="header-anchor">#</a> 25、输入URL发生了什么</h2> <ul><li>1、DNS域名解析： 域名解析成IP地址</li> <li>2、浏览器与目标服务器建立一个TCP链接</li> <li>3、浏览器向服务器发送请求报文</li> <li>4、服务器向浏览器发送响应报文</li> <li>5、浏览器进行渲染</li> <li>6、关闭TCP链接</li></ul> <h2 id="_26、浏览器渲染的步骤"><a href="#_26、浏览器渲染的步骤" class="header-anchor">#</a> 26、浏览器渲染的步骤</h2> <ul><li>第一步，HTML转换成DOM</li> <li>第二步，CSS转换成浏览器可理解的styleSheets，然后计算DOM节点的样式</li> <li>第三步，创建布居树，计算元素的布局信息</li> <li>第四步，对布居树进行分层，构建分层树</li> <li>第五步，为每个图层生产绘制列表，并将其提交到合成线程</li> <li>第六步，合成线程将图层转化为图块，进而将图块转化成位图</li> <li>第七步，合成线程发送绘制命令给浏览器</li> <li>第八步，浏览器根据绘制命令生成页面，并显示到显示器上。</li></ul> <h2 id="_27、vue-router的几种模式和守卫"><a href="#_27、vue-router的几种模式和守卫" class="header-anchor">#</a> 27、Vue-router的几种模式和守卫</h2> <blockquote><p>模式有hash何history
守卫有</p></blockquote> <ul><li>全局守卫： beforEach路由进入之前，afterEach路由进入之后</li> <li>组件内守卫：beforRouterEnter路由进入之前，beforRouterUpdate路由更新之前，beforRouterLeave路由离开之前</li> <li>路由独享守卫： beforEnter路由进入之前</li></ul> <h2 id="_28、bfc"><a href="#_28、bfc" class="header-anchor">#</a> 28、BFC</h2> <ul><li>BFC：块级格式化上下文，属于流动模型布局，具有BFC特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素</li></ul> <blockquote><p>行成BFC的条件</p></blockquote> <ul><li>body根元素</li> <li>浮动元素,float除了none以外的值</li> <li>绝对定位元素： position(absolute,fixed)</li> <li>display的inline-block,table-cells,flex</li> <li>overflow除了visible以外的值(hidden,auto,scroll)</li></ul> <blockquote><p>BFC常见作用</p></blockquote> <ul><li>阻止外边距折叠：如标准文档流里，块级标签之间竖直方向的margin会以大的为准，可以用overflow:hidden产生BFC来解决</li> <li>包含浮动元素</li> <li>阻止元素被浮动元素覆盖</li></ul> <h2 id="_29、响应式布局的方式"><a href="#_29、响应式布局的方式" class="header-anchor">#</a> 29、响应式布局的方式</h2> <ul><li>媒体查询</li> <li>百分比布局</li> <li>rem布局</li> <li>vh/vw单位</li></ul> <h2 id="_30、垂直居中的方法"><a href="#_30、垂直居中的方法" class="header-anchor">#</a> 30、垂直居中的方法</h2> <ul><li>使用绝对定位和负外边距</li> <li>使用绝对定位和transform： transform: translate(0, -50%);</li> <li>绝对定位结合 margin: auto</li> <li>使用padding</li> <li>flex布局： aligin-items: center（横向居中是justify-content: center）</li> <li>line-height对单行文本进行垂直居中</li></ul> <h2 id="_31、webpack-五个核心概念"><a href="#_31、webpack-五个核心概念" class="header-anchor">#</a> 31、webpack 五个核心概念</h2> <ul><li>Entry 入口(Entry) 指示 webpack 以哪个文件为入口起点开始打包，分析构建内部依赖图。</li> <li>Output 输出(Output) 指示 webpack 打包后的资源 bundles 输出到哪里去，以及如何命名。</li> <li>Loader Loader 让 webpack 能 够 去 处 理 那 些 非 JavaScript 文 件 (webpack 自 身 只 理 解 JavaScript)</li> <li>Plugins 插件(Plugins)可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩， 一直到重新定义环境中的变量等</li> <li>Mode 模式(Mode)指示 webpack 使用相应模式的配置</li></ul> <h2 id="_32、webpack的loader和plugin的区别"><a href="#_32、webpack的loader和plugin的区别" class="header-anchor">#</a> 32、webpack的loader和plugin的区别</h2> <ul><li>loader 用于加载某些资源文件。</li></ul> <p>因为 webpack 只能理解 JavaScript 和 JSON 文件，对于其他资源例如 css，图片，或者其他的语法集，比如 jsx， coffee，是没有办法加载的。 这就需要对应的loader将资源转化，加载进来。从字面意思也能看出，loader是用于加载的，它作用于一个个文件上。</p> <ul><li>plugin 用于扩展webpack的功能。</li></ul> <p>目的在于解决loader无法实现的其他事,它直接作用于 webpack，扩展了它的功能。当然loader也是变相的扩展了 webpack ，但是它只专注于转化文件（transform）这一个领域。而plugin的功能更加的丰富，而不仅局限于资源的加载</p> <h2 id="_33、tcp三次握手-建立连接"><a href="#_33、tcp三次握手-建立连接" class="header-anchor">#</a> 33、TCP三次握手 建立连接</h2> <ul><li>第一次握手：客户端发送syn包(seq=x)到服务器，并进入SYN_SENT状态，等待服务器确认；</li> <li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li> <li>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li></ul> <h2 id="_34、tcp四次挥手-断开连接"><a href="#_34、tcp四次挥手-断开连接" class="header-anchor">#</a> 34、TCP四次挥手 断开连接</h2> <ul><li>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。</li> <li>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。</li> <li>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</li> <li>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手</li></ul> <h2 id="_35、script标签为什么要放在底部"><a href="#_35、script标签为什么要放在底部" class="header-anchor">#</a> 35、script标签为什么要放在底部</h2> <p>因为浏览器在渲染HTML的时候是从上到下依次执行，</p> <p>遇到script标签则会停止DOM树的渲染，优先下载js文件，</p> <p>如果文件很大，则导致页面加载时间过长，影响用户体验</p> <h2 id="_36、介绍一下http缓存"><a href="#_36、介绍一下http缓存" class="header-anchor">#</a> 36、介绍一下http缓存</h2> <blockquote><p>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术，使用缓存的优点：</p></blockquote> <ul><li>减少冗余的数据传输</li> <li>减少服务器负担</li> <li>加快客户端加载网页的速度<br>
根据是否需要向服务器重新发起 HTTP 请求将缓存过程分为两个部分，分别是 强缓存 和 协商缓存(弱缓存、对比缓存) 。</li></ul> <blockquote><p>强缓存
强缓存是利用 http 的返回头中的 Expires 或者 Cache-Control 字段来控制的，用来表示资源在客户端缓存的有效期，Cache-Control 的优先级更高
协商缓存</p></blockquote> <p>协商缓存就是强缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。如果协商缓存命中，则返回 304 状态码并且会显示一个 Not Modified 的字符串，如果未命中，则会返回 200 状态码及最新的资源和缓存标识。</p> <h2 id="_37、spa单页面应用和多页面应用有什么区别"><a href="#_37、spa单页面应用和多页面应用有什么区别" class="header-anchor">#</a> 37、SPA单页面应用和多页面应用有什么区别</h2> <blockquote><p>单页面优点：</p></blockquote> <ul><li><p>减小服务器压力：如果不用单页面（spa），如果每次切换页面的时候，都向服务器发送一个请求，服务器返回一个html文件；但是如果使用了单页面，在切换时，不需要请求服务器，只要通过本地的js来切换即可。</p></li> <li><p>服务器端就不需要配置路由，完全做到了前后端分离 -增强用户体验，增加app的使用流畅性。 使用spa之后，页面在切换的时候非常流畅，完全没有那种不断刷新的感觉，而是非常快的就有了响应，因为js运行速度很快，所以js在做本地路由的时候，就会非常快。</p></li></ul> <blockquote><p>单页面缺点</p></blockquote> <ul><li>首屏时间慢：单页应用的首屏时间慢，首屏时需要请求一次html，同时还要发送一次js请求，两次请求回来了，首屏才会展示出来。相对于多页应用，首屏时间慢</li> <li>SEO效果差，因为搜索引擎只认识html里的内容，不认识js的内容，而单页应用的内容都是靠js渲染生成出来的，搜索引擎不识别这部分内容，也就不会给一个好的排名，会导致单页应用做出来的网页在百度和谷歌上的排名差。</li></ul></div></article> <!----></div></main> <aside class="aside" data-v-b3fda33c data-v-b3fda33c><div class="info-card main-div" data-v-1311ce9e data-v-b3fda33c><div class="info-card-header" data-v-1311ce9e><img src="/blog/avatar-top.jpeg" alt="黄文杰" class="info-avatar" data-v-1311ce9e></div> <div class="info-card-body" data-v-1311ce9e><section class="info-name" data-v-1311ce9e>
      黄文杰
    </section> <section class="info-desc" data-v-1311ce9e>好好学习<br/>天天向上</section> <section class="info-contact" data-v-1311ce9e><section data-v-1311ce9e><span data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:1em;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-location" data-v-1311ce9e data-v-1311ce9e></use></svg><span class="info-text" data-v-1311ce9e data-v-1311ce9e>
          Guangzhou, China
        </span></span></section> <!----> <section data-v-1311ce9e><span data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:1em;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-email" data-v-1311ce9e data-v-1311ce9e></use></svg><span class="info-text" data-v-1311ce9e data-v-1311ce9e>
          879771632@qq.com
        </span></span></section></section></div> <div class="info-card-footer" data-v-1311ce9e><p class="footer-sns-link" data-v-1311ce9e><a target="_blank" href="" class="sns-link" data-v-1311ce9e><span class="sns-icon" data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:35px;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-weibo" data-v-1311ce9e data-v-1311ce9e></use></svg></span></a><a target="_blank" href="" class="sns-link" data-v-1311ce9e><span class="sns-icon" data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:35px;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-zhihu" data-v-1311ce9e data-v-1311ce9e></use></svg></span></a><a target="_blank" href="" class="sns-link" data-v-1311ce9e><span class="sns-icon" data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:35px;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-github" data-v-1311ce9e data-v-1311ce9e></use></svg></span></a></p></div></div> <div class="post-toc main-div aside-toc" style="position:relative;top:0;width:0px;" data-v-b3fda33c><h4>- CATALOG</h4> <div class="post-nav-toc"><ul><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1、说一下盒子模型">1、说一下盒子模型</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2、说一下-call、apply、bind有什么区别和应用场景">2、说一下 call、apply、bind有什么区别和应用场景</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_3、js的原型和原型链">3、js的原型和原型链</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_4、js的数据类型有哪些-以及检测数据类型的方法">4、js的数据类型有哪些，以及检测数据类型的方法</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_5、display有哪些属性">5、display有哪些属性</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_6、csrf和xss是什么-如何避免">6、csrf和xss是什么，如何避免</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_7、let-const-var区别">7、let/const/var区别</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_8、什么是虚拟dom">8、什么是虚拟DOM</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_9、vue组件的传值方式">9、vue组件的传值方式</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_10、ajax-和-axios">10、ajax 和 axios</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_11、跨域的处理方式">11、跨域的处理方式</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_12、localstorage-sessionstorage-cookie-session区别">12、localStorage，sessionStorage,cookie,session区别</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_13、http-状态码都有哪些">13、http 状态码都有哪些</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_14、es6有哪些新特性">14、es6有哪些新特性</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_15、promise有哪些方法">15、promise有哪些方法</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_16、vue-watch-和-computed-区别和使用场景">16、Vue watch 和 computed 区别和使用场景</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_17、vue3-和-vue2-的区别">17、vue3 和 vue2 的区别</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_18、虚拟-dom-和真实-dom-的区别">18、虚拟 dom 和真实 dom 的区别</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_19、http和https区别">19、http和https区别</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_20、post和get">20、post和get</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_21、闭包">21、闭包</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_22、this指向">22、this指向</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_23、事件循环机制">23、事件循环机制</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_24、重绘与回流">24、重绘与回流</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_25、输入url发生了什么">25、输入URL发生了什么</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_26、浏览器渲染的步骤">26、浏览器渲染的步骤</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_27、vue-router的几种模式和守卫">27、Vue-router的几种模式和守卫</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_28、bfc">28、BFC</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_29、响应式布局的方式">29、响应式布局的方式</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_30、垂直居中的方法">30、垂直居中的方法</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_31、webpack-五个核心概念">31、webpack 五个核心概念</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_32、webpack的loader和plugin的区别">32、webpack的loader和plugin的区别</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_33、tcp三次握手-建立连接">33、TCP三次握手 建立连接</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_34、tcp四次挥手-断开连接">34、TCP四次挥手 断开连接</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_35、script标签为什么要放在底部">35、script标签为什么要放在底部</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_36、介绍一下http缓存">36、介绍一下http缓存</a></li><li><a href="/blog/posts/2022/07/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_37、spa单页面应用和多页面应用有什么区别">37、SPA单页面应用和多页面应用有什么区别</a></li></ul></div></div></aside></div> <footer class="footer" data-v-7f2e4136><p class="footer-sns-link"><a target="_blank" href="" class="sns-link"><span class="sns-icon"><svg class="icon" style="font-size:40px;"><use xlink:href="#icon-weibo"></use></svg></span></a><a target="_blank" href="" class="sns-link"><span class="sns-icon"><svg class="icon" style="font-size:40px;"><use xlink:href="#icon-zhihu"></use></svg></span></a><a target="_blank" href="" class="sns-link"><span class="sns-icon"><svg class="icon" style="font-size:40px;"><use xlink:href="#icon-github"></use></svg></span></a></p> <div class="copyright"><span id="custom"></span> <!----></div></footer></div><div class="global-ui"><!----><!----></div></div>
    <script src="/blog/assets/js/app.9278b647.js" defer></script><script src="/blog/assets/js/6.b9ade4ff.js" defer></script><script src="/blog/assets/js/13.715791f0.js" defer></script>
  </body>
</html>

<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面试题 - React相关 | 黄文杰 的博客 ｜ huang Blog</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/blog/blog/favicon.ico">
    <meta name="description" content="个人博客">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/blog/assets/css/0.styles.1a0d8da5.css" as="style"><link rel="preload" href="/blog/assets/js/app.9278b647.js" as="script"><link rel="preload" href="/blog/assets/js/6.b9ade4ff.js" as="script"><link rel="preload" href="/blog/assets/js/10.24968df8.js" as="script"><link rel="prefetch" href="/blog/assets/js/11.2e7fcfa4.js"><link rel="prefetch" href="/blog/assets/js/12.66267855.js"><link rel="prefetch" href="/blog/assets/js/13.715791f0.js"><link rel="prefetch" href="/blog/assets/js/14.539a9f7d.js"><link rel="prefetch" href="/blog/assets/js/2.4c97bbdc.js"><link rel="prefetch" href="/blog/assets/js/3.c2dabf62.js"><link rel="prefetch" href="/blog/assets/js/4.fddc1d5b.js"><link rel="prefetch" href="/blog/assets/js/5.384f7650.js"><link rel="prefetch" href="/blog/assets/js/7.fd9016ab.js"><link rel="prefetch" href="/blog/assets/js/8.f26ae0a1.js"><link rel="prefetch" href="/blog/assets/js/9.429b2cc6.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.1a0d8da5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="global-layout" data-v-7f2e4136><header class="header-container" style="background-size:cover;background-repeat:no-repeat;background-position:center;background-attachment:scroll;background-image:url(/blog/home-bg.jpeg);" data-v-93921ff8 data-v-7f2e4136><nav class="navbar" style="position:absolute;opacity:1;transition:all 0.5s ease-in-out;" data-v-93921ff8><a href="/blog/" class="navbar-link router-link-active">
    黄文杰的博客
  </a> <ul class="navbar-links"><li><a href="/blog/" class="router-link-active">
        HOME
      </a></li><li><a href="/blog/about/">
        ABOUT
      </a></li><li><a href="/blog/tags/">
        TAGS
      </a></li></ul> <div id="nav-icon"><span></span><span></span><span></span></div></nav> <div class="header-title" data-v-93921ff8 data-v-93921ff8><h1 data-v-93921ff8>面试题 - React相关</h1> <p data-v-93921ff8></p></div></header> <div class="container" data-v-b3fda33c data-v-7f2e4136><main class="main" style="width:60%;" data-v-b3fda33c><div class="post" data-v-b3fda33c data-v-b3fda33c><article class="main-div"><div class="post-content content content__default"><h2 id="_1-1、react生命周期"><a href="#_1-1、react生命周期" class="header-anchor">#</a> 1.1、React生命周期</h2> <div class="language- extra-class"><pre class="language-text"><code>class Test extends React.Component{
    constructor(props){ // 构造函数
        super(props)
        this.state = {}
    }
    // 初始化，更新时会调用
    static getDerivedStateFromProps(props,state){
        // 必须返回一个对象，会和state合并
        return {}
    }
    // 初始化渲染时使用
    componentDidMount(){}
    // 组件更新时调用 返回false 不更新
    shoudComponentUpdate(prevProps,nextState){ return true }
    // 组件更新时调用，返回的值会设置在componentDidUpdate的第三个参数
    getSnapshotBeforeUpdate(prevprops,nextState) { return ''}
    // 组件更新后调用
    componentDidUpdate(preProps,preState,valueFromSnaspshot){}
    // 组件卸载时调用
    componentWillUnmount() {}
    // 组件抛出错误
    static getDerivedStateFromError(){}
}
</code></pre></div><p><img src="/blog/images/React%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/b8256be3fb51644e5c0e11489db35381_1500x797.webp" alt="图片"></p> <h2 id="_1-2、jsx"><a href="#_1-2、jsx" class="header-anchor">#</a> 1.2、JSX</h2> <blockquote><p>JSX：JSX 本质是javascript的语法拓展，它和模板语言相似，但是具备javascript的能力，直白的说，JSX 是React.createElement()的语法糖</p></blockquote> <ul><li>JSX会编译成React.createElement(),React.createElement将返回一个ReactElement的js对象，编译工作交由babel操作</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;div className=&quot;testDiv&quot;&gt;&lt;h1 className=&quot;testH1&quot;&gt;content&lt;/h1&gt;&lt;/div&gt;
// 上面jsx代码会转译成下面内容 React.createElement(标签名，标签参数，标签内容)
React.createElement('div',{ className: 'testDiv'},
   React.createElement('h1', { className: 'testH1' }, 'content')
)
</code></pre></div><h2 id="_1-3、类组件和函数组件"><a href="#_1-3、类组件和函数组件" class="header-anchor">#</a> 1.3、类组件和函数组件</h2> <ul><li><p>在开发的时候，类组件是基于面向对象编程的，主打继承、生命周期等核心概念，而函数组件的内核是函数式编程，主打immutable/引用透明等</p></li> <li><p>性能优化上，类组件主要依靠shouldComponentUpdate来阻断渲染来提升性能，而函数组件依靠React.memo缓存渲染结果来提高性能</p></li> <li><p>从趋势上，React官方更推崇 组合优于继承 的设计概念，所以未来函数组件成为主推方案的概率会大些</p></li></ul> <h2 id="_1-4、react组件设计模式"><a href="#_1-4、react组件设计模式" class="header-anchor">#</a> 1.4、react组件设计模式</h2> <blockquote><p>无状态组件(展示组件)</p></blockquote> <p>只作展示、独立运行、不额外增加功能的组件，特点是复用性强，可分为<code>代理组件</code>，<code>样式组件</code>，<code>布局组件</code></p> <blockquote><p>有状态组件(灵巧组件)</p></blockquote> <p>包含业务逻辑和数据状态的组件称为有状态组件，或者灵巧组件，特点是功能丰富、复杂度高、复用性低，有状态组件分为 <code>容器组件</code>和<code>高阶组件</code></p> <ul><li>容器组件 - 几乎没有复用性，主要用于拉取数据和组合组件</li> <li>高阶组件 - 实际是一个函数概念，一个函数可以接收另一个函数作为参数，然后返回一个函数，称为高阶函数</li></ul> <h2 id="_1-5、高阶组件"><a href="#_1-5、高阶组件" class="header-anchor">#</a> 1.5、高阶组件</h2> <ul><li>实际是一个函数概念，一个函数可以接收另一个函数作为参数，然后返回一个函数，称为高阶函数</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 高阶组件 判断登录状态
const checkLogin = (WrappedCompont) =&gt; {
    return props =&gt; {
        const isLogin = true; // 这里是登录判断条件，根据实际处理，未登录则显示登录组件
        return isLogin ? &lt;WrappedCompont {...props} /&gt; : &lt;LoginPage /&gt;
    }
}
// 调用高阶组件，函数写法
class Demo extends React.Component{}
const DemoPage = checkLogin(Demo)
// 装饰器写法
@checkLogin
class Demo extends React.Component{}
</code></pre></div><h2 id="_1-6、setstate的同步异步"><a href="#_1-6、setstate的同步异步" class="header-anchor">#</a> 1.6、setState的同步异步</h2> <ul><li>setState是先存入state队列还是直接更新，根据isBatchingUpdates值判断，true则存入队列(异步)，否则直接更新(同步)</li> <li>在react可控制的事件里，是执行异步，如react的生命周期事件和合成事件(如onClick)</li> <li>在react无法控制的事件，则执行同步，如原生事件、addEventListener、setTimeout等</li></ul> <h2 id="_1-7、调用setstate后会发生什么"><a href="#_1-7、调用setstate后会发生什么" class="header-anchor">#</a> 1.7、调用setState后会发生什么</h2> <ul><li>调用setState后，react会将传入的参数对象和组件当前的状态合并，然后触发调和过程返回新的状态，react会根据新的状态构建新的DOM树，然后重新渲染</li></ul> <h2 id="_1-8、组件通信"><a href="#_1-8、组件通信" class="header-anchor">#</a> 1.8、组件通信</h2> <blockquote><p>单层级通信</p></blockquote> <ul><li>父组件给子组件通信，传递props</li> <li>子组件向父组件通信，使用回调函数</li> <li>兄弟组件通信，通过父组件当中间件传递</li></ul> <blockquote><p>跨多层组件通信</p></blockquote> <ul><li>React的context api</li> <li>使用全局变量和事件，绑定在window</li> <li>使用状态管理框架，如 redux</li> <li>自定义事件订阅模式组件(不推荐，不好管理)</li></ul> <h2 id="_1-9、虚拟dom的工作原理-virtual-dom-也称vdom-也就是虚拟dom"><a href="#_1-9、虚拟dom的工作原理-virtual-dom-也称vdom-也就是虚拟dom" class="header-anchor">#</a> 1.9、虚拟DOM的工作原理，Virtual DOM 也称VDOM，也就是虚拟DOM</h2> <blockquote><p>虚拟DOM的工作原理是通过js对象模拟DOM的节点<br>
以react为例，在render函数中写的jsx会在babel插件下，编译为React.createElement执行的JSX中的属性参数，<br>
React.createElement执行后会返回一个描述节点的对象，描述自己的tag类型，props属性以及children 子级等，<br>
这些对象通过树形结构组成一个虚拟DOM树，在状态发生改变时，对比更新前后虚拟DOM树的差异，这个过程称为diff，生成的结果称为patch，计算之后，会渲染patch完成对真实DOM的操作</p></blockquote> <blockquote><p>虚拟DOM优点</p></blockquote> <ul><li>改善大规模DOM操作的性能</li> <li>规避XSS风险</li> <li>以较低成本实现跨平台开发</li></ul> <blockquote><p>虚拟DOM缺点</p></blockquote> <ul><li>内存占用较高(因为需要模拟整个网页的真实DOM)</li> <li>高性能应用场景存在难以优化的情况</li></ul> <h2 id="_1-10、diff算法"><a href="#_1-10、diff算法" class="header-anchor">#</a> 1.10、diff算法</h2> <blockquote><p>diff算法是指生成更新补丁的方式，主要运用于虚拟DOM树变化后，更新真实DOM</p></blockquote> <p>react的diff算法，触发更新的时间主要是在state变化和hooks调用之后。此时触发虚拟DOM树变更遍历，采用了深度优先的遍历算法，采用3种类型节点的比对，分别是树、组件和元素</p> <ul><li>树比对 - 由于网页视图中较少出现跨层级节点移动，所以两个虚拟DOM树只对同一层级的节点进行比较</li> <li>组件比对 - 如果组件是同一类型，则进行树对比，如果不是则直接放入补丁中</li> <li>元素比对 - 主要发生在同层级中，通过节点标记(key)操作生成补丁，节点操作对应真实DOM的操作</li></ul> <blockquote><p>React16起，引入了Fiber架构，是为了使整个更新过程可以随时暂停和恢复，节点和树分别采用了FiberNode和FiberTree进行重构，FiberNode使用了双链表的结构，可以直接找到兄弟节点和子节点</p></blockquote> <h2 id="_1-11、react渲染流程"><a href="#_1-11、react渲染流程" class="header-anchor">#</a> 1.11、react渲染流程</h2> <ul><li>react16以后的渲染流程是Fiber Reconciler</li></ul> <blockquote><p>Fiber Reconciler特点</p></blockquote> <ul><li>协作性多任务模式 - 线程会定时放弃自己当前运行权利，交给主线程运行</li> <li>策略性优先级 - 调度任务通过标记tag的方式区分优先级执行</li></ul> <blockquote><p>渲染过程基本可以划分为 Render 和 Commit 两个阶段</p></blockquote> <ul><li>Render 阶段主要是计算出diff树，自下而上逐个节点检查并构造新的树，特点是可终止</li> <li>Commit 阶段是根据diff更新DOM树，回调生命周期等，同步执行，不可中断暂停</li></ul> <h2 id="_1-12、key的作用"><a href="#_1-12、key的作用" class="header-anchor">#</a> 1.12、key的作用</h2> <ul><li>key是react用于追踪哪些列表的元素被更改的辅助标识</li></ul> <p>在开发过程中，需要保证某个元素的key在同级元素中是唯一的</p> <p>在react diff算法中react会借助元素的key值来判断该元素是新创建的还是被移动而来的元素，从而减少不必要的元素重渲染</p> <h2 id="_1-13、createelement和cloneelement的区别"><a href="#_1-13、createelement和cloneelement的区别" class="header-anchor">#</a> 1.13、createElement和cloneElement的区别</h2> <ul><li>React.createElement和React.cloneElement都是用来创建react元素的，区别是传参不一样</li> <li>createElement传入的第一个参数是react元素，而cloneElement第一个参数是element</li></ul> <h2 id="_1-14、受控组件和不受控组件"><a href="#_1-14、受控组件和不受控组件" class="header-anchor">#</a> 1.14、受控组件和不受控组件</h2> <ul><li>每当表单状态发生变化时，都会被写入组件的state中，这种组件成为受控组件</li> <li>受控组件：没有维持自己的状态，状态由父组件控制，仅通过父组件的props获取当前值，然后通过回调函数通知更改</li> <li>不受控组件：保持着自己的状态，refs用于获取当前值</li></ul> <h2 id="_1-15、context-多层级通信"><a href="#_1-15、context-多层级通信" class="header-anchor">#</a> 1.15、context 多层级通信</h2> <p>context的作用是为了避免在组件间层层传递变量，我们可以通过createContext(null)来创建一个新的context，新创建的context包含一个provider 和一个consumer</p> <p>传递时，需要用Provider包裹父组件，在Provider包裹下的层层组件中，通过consumer包裹子组件来读取穿度的变量</p> <h2 id="_1-16、组件状态保存-类似vue的keep-alive"><a href="#_1-16、组件状态保存-类似vue的keep-alive" class="header-anchor">#</a> 1.16、组件状态保存(类似vue的keep-alive)</h2> <ul><li>vue的keep-alive是把虚拟DOM 保存在内存中，React认为容易造成内存泄漏，所以官方不提供状态保存方案</li></ul> <blockquote><p>1、手动保存状态</p></blockquote> <p>配合componentWillUnmount生命周期，通过redux之类的状态管理框架对数据进行保存，通过componentDidMount进行数据恢复，但数据量大的时候比较麻烦</p> <blockquote><p>2、通过路由实现保存 react-router</p></blockquote> <p>这个方法实现比较麻烦，原理是因为react状态丢失是由于路由切换卸载了组件引起的，所以从根本上改变路由对组件的渲染行为，有以下方式</p> <ul><li>重写组件 - 可参考 react-live-route，实现成本比较高</li> <li>重写路由库 - 可参考 react-keeper, 实现成本和风险更高</li></ul> <blockquote><p>3、模拟真实功能</p></blockquote> <p>github 有类似的实现插件 <code>react-activation</code>，实现原理是：由于react 会卸载掉处于固有组件层级内的组件，所以我们需要将children子属性抽取处理，渲染到一个不会被卸载的组件内，再使用DOM操作将其真实内容移到对应的内容，实现此功能</p> <h2 id="_1-17、useeffect和uselayouteffect"><a href="#_1-17、useeffect和uselayouteffect" class="header-anchor">#</a> 1.17、useEffect和useLayoutEffect</h2> <blockquote><p>相同点</p></blockquote> <ul><li>useEffect和useLayoutEffect都是用于处理副作用，也就是改变DOM、设置订阅、操作定时器等</li> <li>使用方法一样，底层也一样，都是调用mountEffectlmpl方法，基本可以直接替换</li></ul> <blockquote><p>不同点</p></blockquote> <ul><li>useEffect在React渲染过程中是被异步调用的，用于绝大部分场景，而useLayoutEffect会在所有DOM变更后同步调用，主要处理DOM操作、调整样式、避免页面闪烁灯问题，因为是同步，所以在较大计算量时会造成阻塞</li> <li>useLayoutEffect总是会比useEffect先执行</li></ul> <h2 id="_1-18、react-hooks使用限制"><a href="#_1-18、react-hooks使用限制" class="header-anchor">#</a> 1.18、react-hooks使用限制</h2> <blockquote><p>主要有两个限制</p></blockquote> <ul><li>不要在循环、条件、嵌套函数中调用hook</li> <li>在react的函数组件中调用hook<br>
因为hooks的设计是基于数组实现，在调用时是按顺序加入数组中，如果使用循环、条件等有可能会导致数组取值错位，导致执行到错误的hook</li></ul> <h2 id="_1-19、immutable"><a href="#_1-19、immutable" class="header-anchor">#</a> 1.19、immutable</h2> <ul><li><p>immutable 是指不可改变的数据，创建后不会更改，任何修改都会返回一个新的immutable对象</p></li> <li><p>使用immutable可以给react应用带来性能的优化，主要体现在减少渲染次数</p></li> <li><p>在react性能优化的时候，为了避免重复渲染，通常是在shouleComponentUpdate中做对比，判断返回是否需要返回true更新</p></li> <li><p>immutable通过is方法可以完成对比，无需通过深度比较的方式比较</p></li></ul> <h2 id="_1-20、react性能优化方法"><a href="#_1-20、react性能优化方法" class="header-anchor">#</a> 1.20、React性能优化方法</h2> <ul><li>1、减少渲染的节点、降低渲染的计算量(复杂度)</li> <li>2、避免重复渲染，类组件通过shouldComponentUpdate来比对state和props(浅比较)，确认是否需要重新渲染，函数组件则是用React.memo
<ul><li>shouldComponentUpdate：React.PureComponent类内置了对shouldComponentUpdate的实现，如果要深对比，可以加入Immutable.js</li> <li>memo和useMemo：两个都是函数组件的优化思路</li> <li>React.memo是函数版的shouldComponentUpdate，但只针对props，不针对state的变化</li> <li>useMemo则是更加精细的memo，可以控制是否需要重复执行某一段逻辑</li></ul></li></ul> <h2 id="_1-21、react懒加载"><a href="#_1-21、react懒加载" class="header-anchor">#</a> 1.21、react懒加载</h2> <ul><li>react16.6 新增了React.lazy函数，配合webpack的codesplitting可以实现懒加载，只有组件加载时才会导入对应资源</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 不用lazy
import otherComponent from './otherComponent'
// 使用lazy
const otherComponent = React.lazy(()=&gt;import('./otherComponent'))
</code></pre></div><h2 id="_1-22、useeffect如何区分生命周期"><a href="#_1-22、useeffect如何区分生命周期" class="header-anchor">#</a> 1.22、useEffect如何区分生命周期</h2> <ul><li>useEffect可以看成是 componentDidMount、componentDidUpdate和componentWillUnmount三者的结合</li></ul> <div class="language- extra-class"><pre class="language-text"><code>useEffect(()=&gt;{
    console.log('mounted')
    return ()=&gt;{ console.log('willunmount') }
},[source])

// source不传则是默认componentDidMount，传参后就是对应参数的componentDidUpdate
</code></pre></div><h2 id="_1-23、常见的hook"><a href="#_1-23、常见的hook" class="header-anchor">#</a> 1.23、常见的hook</h2> <ul><li>useState - 状态钩子，定义组件的state</li> <li>useEffect - 生命周期钩子</li> <li>useContext - 获取context对象</li> <li>useCallback - 缓存回调函数，避免传入的回调每次都是新的函数实例而导致依赖组件重新渲染</li> <li>useMemo - 缓存传入的props,避免重复渲染</li> <li>useRef - 获取组件的真实节点</li></ul> <h2 id="_1-24、不同版本做过什么优化"><a href="#_1-24、不同版本做过什么优化" class="header-anchor">#</a> 1.24、不同版本做过什么优化</h2> <blockquote><p>React15: 架构可以分为两层</p></blockquote> <ul><li>reconciler(协调器) - 负责找出变化的组件</li> <li>render(渲染器) - 负责把变化的组件渲染到页面上</li></ul> <p>在React15及以前，reconciler(协调器)采用递归的方式创建虚拟DOM，递归过程是不可中断的，如果层级很深，递归时间超过了16ms，用户交互就会卡顿</p> <p>因此，React将递归改成异步可中断的Filber</p> <ul><li>React16: 架构可分为三层</li> <li>scheduler(调度器) - 负责调度任务的优先级，优先级高的任务先进入reconciler</li> <li>reconciler(协调器) - 负责找出变化的组件</li> <li>render(渲染器) - 负责把变化的组件渲染到页面上</li></ul> <h2 id="_1-25、如何理解react"><a href="#_1-25、如何理解react" class="header-anchor">#</a> 1.25、如何理解react</h2> <ul><li><p>React是一个网页UI框架，通过组件化的方式解决视图层开发复用的问题，本质上是一个组件化框架</p></li> <li><p>它的设计核心思路有三点： 声明式，组件化和通用性</p></li> <li><p>声明式的优势在于直观和组合</p></li> <li><p>组件化的优势在于视图的拆分与模块复用，可以更容易做到高内聚低耦合</p></li> <li><p>通用性在于一次学习，随处编写，比如react native等，这里主要靠虚拟DOM来保证实现</p></li> <li><p>React的劣势在于它没有提供完整的解决方案，需要开发者自行整合，比如react-router等</p></li></ul> <h2 id="_1-26、副作用"><a href="#_1-26、副作用" class="header-anchor">#</a> 1.26、副作用</h2> <ul><li><p>纯函数</p></li> <li><p>确定的输入，产生确定的输出，与执行次数、时间无关</p></li> <li><p>不产生副作用</p></li> <li><p>常见副作用</p></li> <li><p>系统IO相关API</p></li> <li><p>Date.now()、Math.random()等不确定性方法</p></li> <li><p>在函数体内修改函数外变量的值</p></li> <li><p>在函数体内修改函数参数的值</p></li> <li><p>调用会产生副作用的函数</p></li> <li><p>http请求</p></li></ul> <h2 id="_2-1、redux是什么"><a href="#_2-1、redux是什么" class="header-anchor">#</a> 2.1、redux是什么</h2> <blockquote><p>redux是一个实现状态集中管理的容器，遵循三大基本原则</p></blockquote> <ul><li>单一数据源</li> <li>state是只读的</li> <li>使用纯函数来执行修改<br>
store的数据，通过dispatch来派发action</li></ul> <blockquote><p>redux工作流程</p></blockquote> <p>view 调用store的dispatch接收action传入store,reducer进行state操作，然后view通过store提供的getState获取最新的数据</p> <h2 id="_2-2、常用中间件"><a href="#_2-2、常用中间件" class="header-anchor">#</a> 2.2、常用中间件</h2> <ul><li>redux-thunk - 用于异步操作</li> <li>redux-promise - 处理异步操作</li> <li>redux-sage - 处理异步操作</li> <li>redux-logger - 用于日志记录</li></ul> <h2 id="_2-3、react-redux"><a href="#_2-3、react-redux" class="header-anchor">#</a> 2.3、react-redux</h2> <ul><li><p>react-redux是官方推荐的库，具有高效且灵活的特性</p></li> <li><p>react-redux分成两个核心provider 和 connection</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>// Provider
&lt;Provider store = {store}&gt; &lt;App /&gt; &lt;/Provider&gt;

// connection
import { connect } from 'react-redux'
// 把redux的数据映射到react的props中去
const mapStateToProps = state =&gt; {
    return {foo: state.foo}
}
// 将redux中的dispatch映射到组件内部的props中去
const mapDispatchToProps = dispatch =&gt;{
    return {
        toclick: () =&gt; { dispatch({type:'toclick'}) }
    }
}
connect(mapStateToProps, mapDispatchToProps)(MyComponent)
</code></pre></div><h2 id="_2-4、reducer"><a href="#_2-4、reducer" class="header-anchor">#</a> 2.4、reducer</h2> <ul><li>reducer是纯函数，它规定应用程序的状态怎样因响应action而变化，reducer通过接收先前的状态和action来工作， 然后返回一个新的状态。</li> <li>它根据操作的类型确定需要执行哪种更新，然后返回新的值，如果不需要完成任务，就会返回原来的状态</li></ul></div></article> <!----></div></main> <aside class="aside" data-v-b3fda33c data-v-b3fda33c><div class="info-card main-div" data-v-1311ce9e data-v-b3fda33c><div class="info-card-header" data-v-1311ce9e><img src="/blog/avatar-top.jpeg" alt="黄文杰" class="info-avatar" data-v-1311ce9e></div> <div class="info-card-body" data-v-1311ce9e><section class="info-name" data-v-1311ce9e>
      黄文杰
    </section> <section class="info-desc" data-v-1311ce9e>好好学习<br/>天天向上</section> <section class="info-contact" data-v-1311ce9e><section data-v-1311ce9e><span data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:1em;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-location" data-v-1311ce9e data-v-1311ce9e></use></svg><span class="info-text" data-v-1311ce9e data-v-1311ce9e>
          Guangzhou, China
        </span></span></section> <!----> <section data-v-1311ce9e><span data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:1em;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-email" data-v-1311ce9e data-v-1311ce9e></use></svg><span class="info-text" data-v-1311ce9e data-v-1311ce9e>
          879771632@qq.com
        </span></span></section></section></div> <div class="info-card-footer" data-v-1311ce9e><p class="footer-sns-link" data-v-1311ce9e><a target="_blank" href="" class="sns-link" data-v-1311ce9e><span class="sns-icon" data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:35px;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-weibo" data-v-1311ce9e data-v-1311ce9e></use></svg></span></a><a target="_blank" href="" class="sns-link" data-v-1311ce9e><span class="sns-icon" data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:35px;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-zhihu" data-v-1311ce9e data-v-1311ce9e></use></svg></span></a><a target="_blank" href="" class="sns-link" data-v-1311ce9e><span class="sns-icon" data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:35px;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-github" data-v-1311ce9e data-v-1311ce9e></use></svg></span></a></p></div></div> <div class="post-toc main-div aside-toc" style="position:relative;top:0;width:0px;" data-v-b3fda33c><h4>- CATALOG</h4> <div class="post-nav-toc"><ul><li><a href="/blog/posts/2022/07/01/react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-1、react生命周期">1.1、React生命周期</a></li><li><a href="/blog/posts/2022/07/01/react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-2、jsx">1.2、JSX</a></li><li><a href="/blog/posts/2022/07/01/react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-3、类组件和函数组件">1.3、类组件和函数组件</a></li><li><a href="/blog/posts/2022/07/01/react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-4、react组件设计模式">1.4、react组件设计模式</a></li><li><a href="/blog/posts/2022/07/01/react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-5、高阶组件">1.5、高阶组件</a></li><li><a href="/blog/posts/2022/07/01/react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-6、setstate的同步异步">1.6、setState的同步异步</a></li><li><a href="/blog/posts/2022/07/01/react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-7、调用setstate后会发生什么">1.7、调用setState后会发生什么</a></li><li><a href="/blog/posts/2022/07/01/react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-8、组件通信">1.8、组件通信</a></li><li><a href="/blog/posts/2022/07/01/react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-9、虚拟dom的工作原理-virtual-dom-也称vdom-也就是虚拟dom">1.9、虚拟DOM的工作原理，Virtual DOM 也称VDOM，也就是虚拟DOM</a></li><li><a href="/blog/posts/2022/07/01/react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-10、diff算法">1.10、diff算法</a></li><li><a href="/blog/posts/2022/07/01/react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-11、react渲染流程">1.11、react渲染流程</a></li><li><a href="/blog/posts/2022/07/01/react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-12、key的作用">1.12、key的作用</a></li><li><a href="/blog/posts/2022/07/01/react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-13、createelement和cloneelement的区别">1.13、createElement和cloneElement的区别</a></li><li><a href="/blog/posts/2022/07/01/react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-14、受控组件和不受控组件">1.14、受控组件和不受控组件</a></li><li><a href="/blog/posts/2022/07/01/react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-15、context-多层级通信">1.15、context 多层级通信</a></li><li><a href="/blog/posts/2022/07/01/react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-16、组件状态保存-类似vue的keep-alive">1.16、组件状态保存(类似vue的keep-alive)</a></li><li><a href="/blog/posts/2022/07/01/react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-17、useeffect和uselayouteffect">1.17、useEffect和useLayoutEffect</a></li><li><a href="/blog/posts/2022/07/01/react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-18、react-hooks使用限制">1.18、react-hooks使用限制</a></li><li><a href="/blog/posts/2022/07/01/react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-19、immutable">1.19、immutable</a></li><li><a href="/blog/posts/2022/07/01/react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-20、react性能优化方法">1.20、React性能优化方法</a></li><li><a href="/blog/posts/2022/07/01/react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-21、react懒加载">1.21、react懒加载</a></li><li><a href="/blog/posts/2022/07/01/react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-22、useeffect如何区分生命周期">1.22、useEffect如何区分生命周期</a></li><li><a href="/blog/posts/2022/07/01/react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-23、常见的hook">1.23、常见的hook</a></li><li><a href="/blog/posts/2022/07/01/react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-24、不同版本做过什么优化">1.24、不同版本做过什么优化</a></li><li><a href="/blog/posts/2022/07/01/react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-25、如何理解react">1.25、如何理解react</a></li><li><a href="/blog/posts/2022/07/01/react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-26、副作用">1.26、副作用</a></li><li><a href="/blog/posts/2022/07/01/react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-1、redux是什么">2.1、redux是什么</a></li><li><a href="/blog/posts/2022/07/01/react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-2、常用中间件">2.2、常用中间件</a></li><li><a href="/blog/posts/2022/07/01/react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-3、react-redux">2.3、react-redux</a></li><li><a href="/blog/posts/2022/07/01/react%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-4、reducer">2.4、reducer</a></li></ul></div></div></aside></div> <footer class="footer" data-v-7f2e4136><p class="footer-sns-link"><a target="_blank" href="" class="sns-link"><span class="sns-icon"><svg class="icon" style="font-size:40px;"><use xlink:href="#icon-weibo"></use></svg></span></a><a target="_blank" href="" class="sns-link"><span class="sns-icon"><svg class="icon" style="font-size:40px;"><use xlink:href="#icon-zhihu"></use></svg></span></a><a target="_blank" href="" class="sns-link"><span class="sns-icon"><svg class="icon" style="font-size:40px;"><use xlink:href="#icon-github"></use></svg></span></a></p> <div class="copyright"><span id="custom"></span> <!----></div></footer></div><div class="global-ui"><!----><!----></div></div>
    <script src="/blog/assets/js/app.9278b647.js" defer></script><script src="/blog/assets/js/6.b9ade4ff.js" defer></script><script src="/blog/assets/js/10.24968df8.js" defer></script>
  </body>
</html>

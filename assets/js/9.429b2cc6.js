(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{578:function(t,_,v){"use strict";v.r(_);var e=v(5),a=Object(e.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"_1-1、-javascript数据类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-1、-javascript数据类型"}},[t._v("#")]),t._v(" 1.1、 Javascript数据类型")]),t._v(" "),v("ul",[v("li",[t._v("原始类型: "),v("code",[t._v("Boolean")]),t._v(","),v("code",[t._v("Null")]),t._v(","),v("code",[t._v("undefined")]),t._v(","),v("code",[t._v("Number")]),t._v(","),v("code",[t._v("String")])]),t._v(" "),v("li",[t._v("引用类型: "),v("code",[t._v("Object")]),t._v(","),v("code",[t._v("Array")])]),t._v(" "),v("li",[t._v("typeof null 是object, 是因为不同对象在底层都是二进制，而object和null的二进制表示都全是0，所以返回了object")])]),t._v(" "),v("h2",{attrs:{id:"_1-2、数据类型判断"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-2、数据类型判断"}},[t._v("#")]),t._v(" 1.2、数据类型判断")]),t._v(" "),v("ul",[v("li",[t._v("1、typeof 对于原始类型来说，除了null都可以显示正确的类型，引用类型则除了函数都是返回object")])]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("typeof 1 // number\ntypeof '1' // string\ntypeof undefined // undefined\ntypeof null // object\ntypeof true // boolean\ntypeof [] // object\ntypeof {} // object\ntypeof console.log // function\n")])])]),v("ul",[v("li",[t._v("2、 instanceof 可以判断对象的类型，是根据原型链来判做判断依据的")])]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("var a = 'test';\na instanceof String // false\n\nvar b = new String('test');\nb instanceof String // true\n\nvar c = function(){};\nvar d = new c();\nd instanceof c // true\n")])])]),v("ul",[v("li",[t._v("3、 Object.prototype.toString")])]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("Object.prototype.toString.call('')  //  [object String]\nObject.prototype.toString.call(1)  // [object Number]\nObject.prototype.toString.call(true)  // [object Boolean]\nObject.prototype.toString.call(null)  // [object Null]\nObject.prototype.toString.call({})  // [object Object]\nObject.prototype.toString.call([])  // [object Array]\n\nObject.prototype.toString.call(new RegExp())  // [object RegExp]\nObject.prototype.toString.call(new Error())  // [object Error]\nObject.prototype.toString.call(document)  // [object HTMLDocument]\nObject.prototype.toString.call(window)  // [object Window]\n")])])]),v("h2",{attrs:{id:"_1-3、this指向"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-3、this指向"}},[t._v("#")]),t._v(" 1.3、this指向")]),t._v(" "),v("ul",[v("li",[t._v("1、在非严格模式下，全局作用域下的普通函数的this指向window，严格模式下，this指向undefined")]),t._v(" "),v("li",[t._v("2、在对象中，this指向被调用的对象")]),t._v(" "),v("li",[t._v("3、在构造函数中，this指向实例对象")]),t._v(" "),v("li",[t._v("4、在箭头函数中，this指向外层作用域的this")])]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("// 在函数中直接使用，指向window\nfunction get(){\n  console.log(this) \n}\nget('1') // 也等于 get.call(window, '1') 打印window\n\n// 函数作为对象的方法被调用，谁调用我，我指向谁\nvar person = {\n  name: '张三',\n  run: function(age){\n    console.log(`${this.name}今年${age}岁`);\n  }\n}\nperson.run(30); // 指向person, 等于person.run.call(person, 30)  打印张三今年30岁\n\n// 在箭头函数中的this是定义函数的时候绑定，而不是在执行函数的时候绑定\nvar x = 1;\nvar obj = {\n  x: 2,\n  say: () => { console.log(this.x) }\n}\nobj.say() // 1\n\n/**\n 箭头函数的this，是继承自父级执行上下文的this，\n 如上的this.x， 箭头函数本身与say平级，也就是箭头函数本身所在的对象为obj，而obj的父级执行上下文是window，所以此时this指向window\n*/\n\n")])])]),v("h2",{attrs:{id:"_1-4、-和"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-4、-和"}},[t._v("#")]),t._v(" 1.4、 == 和 ===")]),t._v(" "),v("p",[t._v("== 和 === 的区别是 == 不会判断双方的数据类型，而 === 会判断数据类型")]),t._v(" "),v("h2",{attrs:{id:"_1-5、闭包"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-5、闭包"}},[t._v("#")]),t._v(" 1.5、闭包")]),t._v(" "),v("blockquote",[v("p",[t._v("什么是闭包")])]),t._v(" "),v("p",[t._v("闭包是可以读取其他函数内部变量的函数")]),t._v(" "),v("blockquote",[v("p",[t._v("闭包的特性")])]),t._v(" "),v("ul",[v("li",[t._v("函数嵌套函数")]),t._v(" "),v("li",[t._v("函数内部可以引用外部的参数和变量")]),t._v(" "),v("li",[t._v("参数和变量不会被垃圾回收机制回收")])]),t._v(" "),v("blockquote",[v("p",[t._v("闭包的作用")])]),t._v(" "),v("p",[t._v("闭包最常见的两个用处是 "),v("code",[t._v("读取函数内部的变量")]),t._v(" 和 "),v("code",[t._v("让变量的值始终保持在内存中")])]),t._v(" "),v("h2",{attrs:{id:"_1-6、内存泄漏"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-6、内存泄漏"}},[t._v("#")]),t._v(" 1.6、内存泄漏")]),t._v(" "),v("blockquote",[v("p",[t._v("什么是内存泄漏")])]),t._v(" "),v("p",[t._v("指的是你用不到(访问不到)的变量，却依旧占据这内存空间，不会再被利用起来，就是内存泄漏")]),t._v(" "),v("blockquote",[v("p",[t._v("闭包造成内存泄漏")])]),t._v(" "),v("p",[t._v("闭包本身不会造成内存泄漏，主要是因为旧版浏览在使用完闭包后，回收不了闭包里面引用的变量，所以造成内存泄漏")]),t._v(" "),v("blockquote",[v("p",[t._v("常见的内存泄漏")])]),t._v(" "),v("ul",[v("li",[t._v("意外的全局变量")]),t._v(" "),v("li",[t._v("被遗忘的计数器或者回调函数")]),t._v(" "),v("li",[t._v("脱离DOM的引用")]),t._v(" "),v("li",[t._v("闭包")])]),t._v(" "),v("h2",{attrs:{id:"_1-7、事件循环-event-loop"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-7、事件循环-event-loop"}},[t._v("#")]),t._v(" 1.7、事件循环 Event Loop")]),t._v(" "),v("blockquote",[v("p",[t._v("单线程")])]),t._v(" "),v("ul",[v("li",[t._v("Javascrpt是 "),v("code",[t._v("单线程")]),t._v("，也就是同一时间只能做一件事")]),t._v(" "),v("li",[v("code",[t._v("任务队列")]),t._v(" - 单线程就意味着，所有任务都需要排队，前面一个任务结束后才执行下一个任务")]),t._v(" "),v("li",[t._v("所有任务可分为 "),v("code",[t._v("同步任务")]),t._v(" 和 "),v("code",[t._v("异步任务")])])]),t._v(" "),v("blockquote",[v("p",[t._v("什么是事件循环")])]),t._v(" "),v("ul",[v("li",[t._v("1、所有同步任务都在主线程上执行，行程一个 "),v("code",[t._v("执行栈")])]),t._v(" "),v("li",[t._v("2、主线程之外，还存在一个 "),v("code",[t._v("任务队列(消息队列)")]),t._v("，只要异步任务有了运行结果，就在这个任务队列中放置一个事件")]),t._v(" "),v("li",[t._v("3、一旦执行栈中所以的同步任务执行完毕，系统会读取任务队列，看看里面有哪些事件，那些对应的异步任务，就会结束等待状态，进入执行栈，开始执行")]),t._v(" "),v("li",[t._v("4、主线程不断重复上面3步")])]),t._v(" "),v("blockquote",[v("p",[t._v("事件循环机制简单说明执行顺序")])]),t._v(" "),v("ul",[v("li",[t._v("1、代码开始执行，创建一个全局调用栈，此时script作为宏任务执行")]),t._v(" "),v("li",[t._v("2、执行完当前所有同步代码后，此时执行栈为空，查询是否有异步代码要执行")]),t._v(" "),v("li",[t._v("3、执行所有微任务")]),t._v(" "),v("li",[t._v("4、执行完微任务后，有需要则渲染页面")]),t._v(" "),v("li",[t._v("5、执行新一轮循环，执行宏任务里的异步代码，比如setTimeout的回调函数")])]),t._v(" "),v("blockquote",[v("p",[t._v("异步任务")])]),t._v(" "),v("ul",[v("li",[v("p",[t._v("异步任务是通过回调函数实现的，所有回调函数都是异步任务，一般有3种类型")]),t._v(" "),v("ul",[v("li",[t._v("普通事件，比如click,resize等")]),t._v(" "),v("li",[t._v("资源加载，如load等")]),t._v(" "),v("li",[t._v("定时器，如setTimeout，setInterval等")])])]),t._v(" "),v("li",[v("p",[t._v("异步任务可细分为"),v("code",[t._v("宏任务")]),t._v("和"),v("code",[t._v("微任务")])]),t._v(" "),v("ul",[v("li",[t._v("微任务包括： Promise,mutationObserve,Process.nextTick")]),t._v(" "),v("li",[t._v("宏任务，非微任务的都是宏任务，如script,setTimeout,setInterval,SetImmediate,I/O,DOM事件，Ajax等")])])])]),t._v(" "),v("h2",{attrs:{id:"_1-8、进程、线程、执行栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-8、进程、线程、执行栈"}},[t._v("#")]),t._v(" 1.8、进程、线程、执行栈")]),t._v(" "),v("blockquote",[v("p",[t._v("进程、线程是CPU工作时间片的一个描述")])]),t._v(" "),v("ul",[v("li",[t._v("进程： CPU在运行指令及加载和保存上下文所需要的时间")]),t._v(" "),v("li",[t._v("线程：是进程中更小的单位，描述了执行一段指令所需的时间")])]),t._v(" "),v("blockquote",[v("p",[t._v("执行栈")])]),t._v(" "),v("ul",[v("li",[t._v("执行栈是一个存储函数调用的栈结构，遵循先进后出的原则，js代码执行就是往执行栈放入函数")])]),t._v(" "),v("h2",{attrs:{id:"_1-9、原型和原型链"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-9、原型和原型链"}},[t._v("#")]),t._v(" 1.9、原型和原型链")]),t._v(" "),v("blockquote",[v("p",[t._v("原型")])]),t._v(" "),v("p",[t._v("任务对象实例都有原型，也叫原型对象，这个原型对象由对象的内置属性 "),v("code",[t._v("__proto__")]),t._v("指向它的构造函数的prototype指向的对象，即任务对象都是由一个构造函数创建的，但不是每一个对象都有prototype，只有方法才有prototype")]),t._v(" "),v("blockquote",[v("p",[t._v("原型链")])]),t._v(" "),v("p",[t._v("当访问一个引用类型的属性时，在自身属性找不到这个属性时，会从隐式原型 __proto__上找，在这个原型找不到时，就会到这个原型的下一级原型上找，如此形成一个链式，就叫原型链")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v('// prototype: 显式原型\n// __proto__: 隐式原型\n\nclass Person{\n  constructor(name){\n    this.name = name\n  }\n  drink() {}\n}\n\nclass Teacher extends Person {\n  constructor(name){\n    this.name = name\n  },\n  teach(){\n    console.log(`我是${this.name}`)\n  }\n}\n\nconst teacher = new Teacher("陈老师)\nteacher.teach() // 我是陈老师，teaher自身没有teach方法，其原型\n// teacher.__proto__ === Teacher.prototype\n')])])]),v("p",[v("img",{attrs:{src:"/blog/images/Javascript%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/WX20220920-172214.png",alt:"图片"}})]),t._v(" "),v("h2",{attrs:{id:"_1-10、变量提升和函数提升"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-10、变量提升和函数提升"}},[t._v("#")]),t._v(" 1.10、变量提升和函数提升")]),t._v(" "),v("p",[t._v("javascript中，函数以及变量的生命会提升到函数的最顶部，这个叫函数的 "),v("code",[t._v("函数提升和变量提升")])]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("// 变量提升\nconsole.log(a)\nvar a = 1\n// 以上代码实际编译时，顺序如下\nvar a;\nconsole.log(a)\na = 1\n\n// 函数提升，函数提升只会提升函数声明，不会提升函数表达式\nconsole.log(fn1) // [Function: fn1]\nfn1(); // fn1\nconsole.log(fn2); // undefined\nfn2(); // typeError: fn2 is not a function\nfunction fn1() {console.log('fn1')}\nvar fn2 = function(){console.log('fn2')}\n\n")])])]),v("h2",{attrs:{id:"_1-11、防抖和节流"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-11、防抖和节流"}},[t._v("#")]),t._v(" 1.11、防抖和节流")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("防抖")]),t._v("： 对于短时间内连续触发的事件，让其在一个时间期限内，只执行一次事件，如滚动事件")])]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("function debounce(fn, time){\n    let timer = null;\n    return function(){\n         if(timer){ clearTimeout(timer) }\n         timer = setTimeout(fn, time)\n    }\n}\ndebounce(todo, 1000); // 1秒内只执行一次todo\n")])])]),v("ul",[v("li",[v("code",[t._v("节流")]),t._v(": 如果一个事件在短时间内大量触发，让它执行一次后，在指定时间内不再执行，如实时搜索框input事件")])]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("function throttle(fn, time){\n    let valid = true\n    return function(){\n        if(!valid) return false; // 处于暂停执行时间\n        valid = false\n        setTimeout(()=>{  \n            fn()\n            valid = true\n        }, time)\n    }\n}\nthrottle(todo, 1000); // 执行todo后1秒内不再执行\n")])])]),v("h2",{attrs:{id:"_1-12、事件冒泡和事件委托"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-12、事件冒泡和事件委托"}},[t._v("#")]),t._v(" 1.12、事件冒泡和事件委托")]),t._v(" "),v("blockquote",[v("p",[t._v("事件冒泡"),v("br"),t._v("\n一个事件触发后，会在子元素和父元素之间传播，传播分为3个阶段")])]),t._v(" "),v("ul",[v("li",[t._v("捕获阶段 - 从window对象传导到目标节点，这个阶段不会响应任何事件")]),t._v(" "),v("li",[t._v("目标阶段 - 在目标节点上触发")]),t._v(" "),v("li",[t._v("冒泡阶段 - 从目标节点传导回window对象")])]),t._v(" "),v("blockquote",[v("p",[t._v("事件委托(事件代理)"),v("br"),t._v("\n事件委托是利用事件冒泡，只制定一个事件处理程序就可以管理某一列子元素的所有事件"),v("br"),t._v("\n比如把原本 item子元素列表的响应事件定义到父元素，由父元素根据实际情况判断触发哪个item子元素")])]),t._v(" "),v("h2",{attrs:{id:"_1-13、es6新特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-13、es6新特性"}},[t._v("#")]),t._v(" 1.13、es6新特性")]),t._v(" "),v("p",[v("code",[t._v("const")]),t._v(","),v("code",[t._v("let")]),t._v(","),v("code",[t._v("模板字符串")]),t._v(","),v("code",[t._v("箭头函数")]),t._v(","),v("code",[t._v("函数的默认参数值")]),t._v(","),v("code",[t._v("对象和数组的解构赋值")]),t._v(","),v("code",[t._v("for……of")]),t._v(","),v("code",[t._v("for……in")]),t._v(","),v("code",[t._v("展开运算符")]),t._v("等")]),t._v(" "),v("h2",{attrs:{id:"_1-14、垃圾回收机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-14、垃圾回收机制"}},[t._v("#")]),t._v(" 1.14、垃圾回收机制")]),t._v(" "),v("ul",[v("li",[t._v("JS的垃圾回收机制是为了防止内存泄漏，间歇的不定期的寻找到不再使用的变量，并释放它们所指向的内存")]),t._v(" "),v("li",[t._v("垃圾回收的方式有\n"),v("ul",[v("li",[t._v("1、标记清除算法 - 标记阶段给活动的对象做上标记，清除阶段把没有标记的对象销毁(缺点：内存碎片化，分配速度慢)")]),t._v(" "),v("li",[t._v("2、引用计数算法 - 如果没有引用指向该对象，则销毁，现在很少使用这算法了")])])])]),t._v(" "),v("h2",{attrs:{id:"_1-15、new操作符做了哪些事情"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-15、new操作符做了哪些事情"}},[t._v("#")]),t._v(" 1.15、new操作符做了哪些事情")]),t._v(" "),v("ul",[v("li",[t._v("1、创建一个空对象，并且this变量引用该对象，同时继承了该函数的原型")]),t._v(" "),v("li",[t._v("2、属性和方法被加入到this引用的对象中")]),t._v(" "),v("li",[t._v("3、新创建的对象由this所引用，最后隐式地返回this")])]),t._v(" "),v("p",[v("code",[t._v("一句话概括 - 新建一个空对象，这个对象原型指向构造函数的prototype，执行构造函数后返回这个对象")])]),t._v(" "),v("h2",{attrs:{id:"_1-16、bind-apply-call"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-16、bind-apply-call"}},[t._v("#")]),t._v(" 1.16、bind,apply,call")]),t._v(" "),v("ul",[v("li",[t._v("call 、apply、bind都是改变this指向的，不同在于他们的调用方式和调用参数不一样")])]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("A.apply(B, [a,b])\nA.call(B, a, b)\nA.bind(B,a,b)()\n")])])]),v("h2",{attrs:{id:"_1-17、箭头函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-17、箭头函数"}},[t._v("#")]),t._v(" 1.17、箭头函数")]),t._v(" "),v("ul",[v("li",[t._v("箭头函数是ES6的API")]),t._v(" "),v("li",[t._v("箭头函数没有prototype,所以箭头函数本身没有this")]),t._v(" "),v("li",[t._v("因为没有this，所以无法使用call/apply/call去改变this的指向")]),t._v(" "),v("li",[t._v("箭头函数不绑定arguments，取而代之用rest参数代替去访问箭头函数的参数列表")]),t._v(" "),v("li",[t._v("箭头函数不能用作generator函数，不能使用yeild关键字")])]),t._v(" "),v("h2",{attrs:{id:"_1-18、构造函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-18、构造函数"}},[t._v("#")]),t._v(" 1.18、构造函数")]),t._v(" "),v("ul",[v("li",[t._v("构造函数和普通函数创建方式一样，但调用方式不同 var a = new A()")]),t._v(" "),v("li",[t._v("构造函数对比普通函数的作用不一样，构造函数是用来创建实例对象的")]),t._v(" "),v("li",[t._v("构造函数的this指向它创建的对象实例")])]),t._v(" "),v("h2",{attrs:{id:"_1-19、promise"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-19、promise"}},[t._v("#")]),t._v(" 1.19、Promise")]),t._v(" "),v("blockquote",[v("p",[t._v("promise常用方法")])]),t._v(" "),v("ul",[v("li",[t._v("resolve()")]),t._v(" "),v("li",[t._v("reject()")]),t._v(" "),v("li",[t._v("then()")]),t._v(" "),v("li",[t._v("catch()")]),t._v(" "),v("li",[t._v("race() - 多个任务同时执行，返回最先执行结束的任务结果，不管成功还是失败")]),t._v(" "),v("li",[t._v("all() - 多个任务同时执行，只有全部成功才返回成功结果，否则都是返回失败结果")])]),t._v(" "),v("blockquote",[v("p",[t._v("promise的3种状态")])]),t._v(" "),v("ul",[v("li",[t._v("pending - 初始状态，也叫等待状态")]),t._v(" "),v("li",[t._v("fulfiled - 成功状态")]),t._v(" "),v("li",[t._v("rejected - 失败状态\n状态一旦改变，就不会再变，创造promise实例后，它会立即执行")])]),t._v(" "),v("blockquote",[v("p",[t._v("promise的特点")])]),t._v(" "),v("ul",[v("li",[t._v("1、Promise对象的状态不受外界影响")]),t._v(" "),v("li",[t._v("2、Promise的状态是不可逆的")])]),t._v(" "),v("blockquote",[v("p",[t._v("promise 的缺点")])]),t._v(" "),v("ul",[v("li",[t._v("无法取消promise，创建后立即执行，无法中途取消")]),t._v(" "),v("li",[t._v("如果不设置回调函数，promise内部会抛出错误，不会反映到外部")]),t._v(" "),v("li",[t._v("当处于pending状态时，无法得知目前是在哪一阶段")])]),t._v(" "),v("blockquote",[v("p",[t._v("promise解决的问题")])]),t._v(" "),v("ul",[v("li",[t._v("解决回调地狱、难以维护的代码")]),t._v(" "),v("li",[t._v("promise 支持多并发，获取并发请求中的数据")])]),t._v(" "),v("h2",{attrs:{id:"_1-20、generator-yield"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-20、generator-yield"}},[t._v("#")]),t._v(" 1.20、generator yield")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("generator")]),t._v("：生成器，是ES6的新内容,作为异步编程的解决方案，用来解决异步任务")]),t._v(" "),v("li",[t._v("用法是在函数上加上*，可以让我们在函数执行的任意地方暂停,下一步执行则使用next，与yield关键字一起使用")]),t._v(" "),v("li",[t._v("yield 表达式本身没有返回值，或者返回undefined")]),t._v(" "),v("li",[t._v("next，方法可以带一个参数，这个参数会被当做上一个yield的返回值")])]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("function* funA(){\n    var y yield console.log(1)\n    yield console.log('2' + y)\n}\nfunction run(){\n    console.log(3)\n}\nconst iter = funA()\niter.next(); // 1\nrun(); // 3\niter.next(‘a'); // 2a\n")])])]),v("h2",{attrs:{id:"_1-21、async-await"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-21、async-await"}},[t._v("#")]),t._v(" 1.21、async await")]),t._v(" "),v("ul",[v("li",[t._v("async 是ES7新出的特性，是一个异步编程的解决方案, 是 generator 函数的语法糖，返回值是promised对象")]),t._v(" "),v("li",[t._v("async 对应的是*")]),t._v(" "),v("li",[t._v("await 对应的是yield")])]),t._v(" "),v("h2",{attrs:{id:"_1-22、cookie-locastorage-settionstorage"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-22、cookie-locastorage-settionstorage"}},[t._v("#")]),t._v(" 1.22、cookie/locaStorage/settionStorage")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("特性")]),t._v(" "),v("th",[t._v("cookie")]),t._v(" "),v("th",[t._v("locaStorage")]),t._v(" "),v("th",[t._v("sessionStorage")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("生命周期")]),t._v(" "),v("td",[t._v("可设置失效时间，默认是关闭浏览器后失效")]),t._v(" "),v("td",[t._v("不主动清除就永久保存")]),t._v(" "),v("td",[t._v("只在当前会话标签有效，关闭标签或浏览器清除")])]),t._v(" "),v("tr",[v("td",[t._v("存储数据大小")]),t._v(" "),v("td",[t._v("4k左右")]),t._v(" "),v("td",[t._v("5M左右")]),t._v(" "),v("td",[t._v("5M左右")])]),t._v(" "),v("tr",[v("td",[t._v("http请求")]),t._v(" "),v("td",[t._v("每次会携带到HTTP请求头中")]),t._v(" "),v("td",[t._v("仅在浏览器保存，不与服务器通信")]),t._v(" "),v("td",[t._v("仅在浏览器保存，不与服务器通信")])])])]),t._v(" "),v("h2",{attrs:{id:"_1-23、script标签的defer和async"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-23、script标签的defer和async"}},[t._v("#")]),t._v(" 1.23、script标签的defer和async")]),t._v(" "),v("ul",[v("li",[t._v("1、不设置async和defer，那么脚本会同步下载并执行，会阻塞后续dom的渲染")]),t._v(" "),v("li",[t._v("2、设置了defer，脚本异步加载，加载完毕后，在触发domContentloader事件之前执行")]),t._v(" "),v("li",[t._v("3、设置async，脚本异步加载，加载完毕后立即执行，并阻塞后续dom渲染，不影响domContentLoaded事件触发")])]),t._v(" "),v("h2",{attrs:{id:"_1-24、设计模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-24、设计模式"}},[t._v("#")]),t._v(" 1.24、设计模式")]),t._v(" "),v("blockquote",[v("p",[t._v("1、外观模式")])]),t._v(" "),v("ul",[v("li",[t._v("就是把多个子级组件中复杂逻辑进行抽离，然后提供一个统一、简洁、易用的API")]),t._v(" "),v("li",[t._v("优点： 减少组件的相互依赖性，提高灵活性")]),t._v(" "),v("li",[t._v("缺点：要修改的时候可能会麻烦，因为多个地方用到，但修改不一定所有地方都要跟着变")])]),t._v(" "),v("blockquote",[v("p",[t._v("2、工程模式")])]),t._v(" "),v("ul",[v("li",[t._v("定义一个对象接口，又子类决定实例化哪个类，然后使子类可以创建或者重写指定的对象，就是一些经常反复使用的合计")]),t._v(" "),v("li",[t._v("优点：提高复用性，代码容易理解，不管过程只管结果")])]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("function demo1(name){console.log(name)}\nfunction demo2(name){console.log(name)}\nfunction exportDemo(demoName, name){\n    switch(demoName){\n        case 'demo1': demo1(name);break;\n        case 'demo2': demo2(name);break;\n    }\n}\nexportDemo('demo1','名字')\n")])])]),v("blockquote",[v("p",[t._v("3、单例模式")])]),t._v(" "),v("p",[t._v("某个功能可以贯穿整个系统去执行的，比如登录框，vuex，redux的store")]),t._v(" "),v("blockquote",[v("p",[t._v("4、观察者模式(发布订阅模式)")])]),t._v(" "),v("p",[t._v("全局定义一个可以发布、订阅的对象、包含on/emit/off/store，比如vue的响应式")]),t._v(" "),v("blockquote",[v("p",[t._v("5、代理模式")])]),t._v(" "),v("p",[t._v("就是为一个对象找一个替代对象，以便对原对象进行访问，使用代理的原因是我们不想对原对象直接进行操作")]),t._v(" "),v("h2",{attrs:{id:"_1-25、map和set的区别-map和object的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-25、map和set的区别-map和object的区别"}},[t._v("#")]),t._v(" 1.25、Map和Set的区别，Map和Object的区别")]),t._v(" "),v("ul",[v("li",[t._v("Set：是一种数据结构，类似数组，成员唯一，Set本身是一种构造函数")]),t._v(" "),v("li",[t._v("Map：是一组键值对的结构")]),t._v(" "),v("li",[t._v("Set和Map主要的应用场景在于 数据重组和数据储存")]),t._v(" "),v("li",[t._v("Set是一种叫做集合的数据结构，Map是一种叫做字典的数据结构")])]),t._v(" "),v("blockquote",[v("p",[t._v("Set和Map区别")])]),t._v(" "),v("ul",[v("li",[t._v("相同点：集合、字典可以存储不重复的值")]),t._v(" "),v("li",[t._v("不同点：集合Set是以 [value,value]的形式存储元素，字典Map是以 [key,valuye]的形式存储")])]),t._v(" "),v("blockquote",[v("p",[t._v("Map和Object区别")])]),t._v(" "),v("ul",[v("li",[t._v("在Object中，key必须是简单数据类型(整数、字符串)，而Map可以是js支持的所有数据类型")]),t._v(" "),v("li",[t._v("Map元素的顺序遵循插入的顺序，而Object没有这个特性")]),t._v(" "),v("li",[t._v("Map继承自Object对象")])]),t._v(" "),v("h2",{attrs:{id:"_2-1、浏览器输入url后发生了什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1、浏览器输入url后发生了什么"}},[t._v("#")]),t._v(" 2.1、浏览器输入URL后发生了什么")]),t._v(" "),v("ul",[v("li",[t._v("1、DNS域名解析，域名解析为IP地址")]),t._v(" "),v("li",[t._v("2、浏览器与目标服务器建立一个TCP链接")]),t._v(" "),v("li",[t._v("3、浏览器向服务器发送请求报文")]),t._v(" "),v("li",[t._v("4、服务器向浏览器发送响应报文")]),t._v(" "),v("li",[t._v("5、浏览器进行渲染")]),t._v(" "),v("li",[t._v("6、关闭TCP链接")])]),t._v(" "),v("h2",{attrs:{id:"_2-2、跨域的方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2、跨域的方式"}},[t._v("#")]),t._v(" 2.2、跨域的方式")]),t._v(" "),v("ul",[v("li",[t._v("1、jsonp - 利用 "),v("code",[t._v("<script>")]),t._v(" 标签没有跨域限制的漏洞,可以获取到json数据，简单兼容性好，仅支持get方式，容易被攻击")]),t._v(" "),v("li",[t._v("2、CORS - 服务器端配置")]),t._v(" "),v("li",[t._v("3、postMessage - HTML5 XML httpRequest的API")]),t._v(" "),v("li",[t._v("4、websocket - HTML5的持久化协议，基于TCP协议，是一种双向通信协议，建立连接后，两端都能主动向对方发送或接受数据，一般用Socket.io,封装了websocket的接口")]),t._v(" "),v("li",[t._v("5、Node中间件代理")]),t._v(" "),v("li",[t._v("6、Nginx 反向代理")])]),t._v(" "),v("h2",{attrs:{id:"_2-3、浏览器渲染步骤"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-3、浏览器渲染步骤"}},[t._v("#")]),t._v(" 2.3、浏览器渲染步骤")]),t._v(" "),v("ul",[v("li",[t._v("1、HTML转换为DOM")]),t._v(" "),v("li",[t._v("2、CSS转换为浏览器可理解的styleSheets，计算DOM节点的样式")]),t._v(" "),v("li",[t._v("3、创建布局树，计算元素的布局信息")]),t._v(" "),v("li",[t._v("4、对布局树进行分层，构建分层树")]),t._v(" "),v("li",[t._v("5、为每个图层生产绘制列表，并将其体积到合成线程")]),t._v(" "),v("li",[t._v("6、合成线程将图层转换为图块，进而将图块转为成位图")]),t._v(" "),v("li",[t._v("7、合成线程发送绘制命令给浏览器")]),t._v(" "),v("li",[t._v("8、浏览器根据绘制命令生产页面，并显示到显示器上")])]),t._v(" "),v("h2",{attrs:{id:"_2-4、页面渲染优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-4、页面渲染优化"}},[t._v("#")]),t._v(" 2.4、页面渲染优化")]),t._v(" "),v("ul",[v("li",[t._v("1、HTML文档结构层次尽量少，最好不深于6层")]),t._v(" "),v("li",[t._v("2、脚本尽量放最后")]),t._v(" "),v("li",[t._v("3、样式结构层次尽量简单")]),t._v(" "),v("li",[t._v("4、脚本减少DOM操作，减少回流和重绘")]),t._v(" "),v("li",[t._v("5、减少js修改样式，通过修改class名称解决")])]),t._v(" "),v("h2",{attrs:{id:"_2-5、强缓存和协商缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-5、强缓存和协商缓存"}},[t._v("#")]),t._v(" 2.5、强缓存和协商缓存")]),t._v(" "),v("ul",[v("li",[t._v("强缓存：第一次请求资源时在http响应头设置一个过期时间，在时效内都将直接从浏览器获取，比如cache-control和expires")]),t._v(" "),v("li",[t._v("协商缓存：通过http响应头字段etag或者last-modified等判断服务器上资源是否修改，有修改则重新获取，没修改则从浏览器缓存获取")])]),t._v(" "),v("h2",{attrs:{id:"_2-6、post和get区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-6、post和get区别"}},[t._v("#")]),t._v(" 2.6、post和get区别")]),t._v(" "),v("ul",[v("li",[t._v("1、get参数通过URL传递，post放在body中")]),t._v(" "),v("li",[t._v("2、get请求在URL中传递的参数有长度限制，post没有")]),t._v(" "),v("li",[t._v("3、get在浏览器回退是无害的，而post会再次提交请求")]),t._v(" "),v("li",[t._v("4、get请求会被浏览器主动cache，post不会")]),t._v(" "),v("li",[t._v("5、get只接受ASCLL字符，post没有限制")]),t._v(" "),v("li",[t._v("6、get产生一个tcp数据包，post产生两个tcp数据包")])]),t._v(" "),v("h2",{attrs:{id:"_2-7、http和https区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-7、http和https区别"}},[t._v("#")]),t._v(" 2.7、HTTP和HTTPS区别")]),t._v(" "),v("h2",{attrs:{id:"_2-8、同源策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-8、同源策略"}},[t._v("#")]),t._v(" 2.8、同源策略")]),t._v(" "),v("p",[t._v("同源策略指的是 协议、域名、端口相同，是一种安全协议")]),t._v(" "),v("h2",{attrs:{id:"_2-9、前端安全方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-9、前端安全方法"}},[t._v("#")]),t._v(" 2.9、前端安全方法")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("XSS脚本攻击: 跨站脚本攻击，是常见和基本的攻击web网站的方法,攻击者通过注入非法的html标签或者javascript代码，从而当用户浏览该网页时，控制用户浏览器")])]),t._v(" "),v("li",[v("p",[t._v("XSS防御方法")])]),t._v(" "),v("li",[v("p",[t._v("httpOnly: 在cookie中设置httpOnly属性，使js脚本无法读取cookie信息")])]),t._v(" "),v("li",[v("p",[t._v("前端加上输入检查，后端做过滤检查")])]),t._v(" "),v("li",[v("p",[t._v("对用户输入的数据做标签转换")])]),t._v(" "),v("li",[v("p",[t._v("CSRF: 跨站点请求伪造，冒充用户发起请求，完成一些违背用户意愿的事，如修改用户信息等")])]),t._v(" "),v("li",[v("p",[t._v("CSRF防御方法")])]),t._v(" "),v("li",[v("p",[t._v("验证码 - 强制用户必须与应用进行交互，才完成请求")])]),t._v(" "),v("li",[v("p",[t._v("表单提交尽量使用post，get相对容易被哪来做CSRF攻击")])]),t._v(" "),v("li",[v("p",[t._v("请求来源限制")])]),t._v(" "),v("li",[v("p",[t._v("token验证 - 默认适合的方案")])])]),t._v(" "),v("h2",{attrs:{id:"_2-10、html5新特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-10、html5新特性"}},[t._v("#")]),t._v(" 2.10、html5新特性")]),t._v(" "),v("ul",[v("li",[t._v("新增了语义化标签 - header/nav/footer/section等")]),t._v(" "),v("li",[t._v("增强型表单 - 新增input的number/url/email/range/color/date等输入型控件，还添加了placeholder/min/max/height/width等表单属性")]),t._v(" "),v("li",[t._v("DOM拓展 - 新增getElementByClassName、classList属性等")]),t._v(" "),v("li",[t._v("原生拖放 - draggable标识是否可拖拽 "),v("code",[t._v('<div draggable="true">James</div>')])]),t._v(" "),v("li",[t._v("媒体元素 - audio和video")]),t._v(" "),v("li",[t._v("web socket - 提供全双工、双向通信")]),t._v(" "),v("li",[t._v("web storage - localStorage和sessionStorage")]),t._v(" "),v("li",[t._v("地理位置 - Geolocation API")]),t._v(" "),v("li",[t._v("canvas绘图")])]),t._v(" "),v("h2",{attrs:{id:"_2-11、css3新特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-11、css3新特性"}},[t._v("#")]),t._v(" 2.11、css3新特性")]),t._v(" "),v("ul",[v("li",[t._v("过渡 - transition")]),t._v(" "),v("li",[t._v("动画 - animation")]),t._v(" "),v("li",[t._v("形状转换 - transform")]),t._v(" "),v("li",[t._v("选择器 - :nth-child,:last-child,:root,:checked等 选择器参考手册")]),t._v(" "),v("li",[t._v("阴影 - box-shadow")]),t._v(" "),v("li",[t._v("边框 - border-image,border-radius")]),t._v(" "),v("li",[t._v("背景 - background-clip/background-origin/background-size")]),t._v(" "),v("li",[t._v("文字 - word-break(换行)，text-overflow")]),t._v(" "),v("li",[t._v("颜色 - rgba")]),t._v(" "),v("li",[t._v("渐变 - gradient")]),t._v(" "),v("li",[t._v("滤镜 - filter")]),t._v(" "),v("li",[t._v("flex - 弹性布局")]),t._v(" "),v("li",[t._v("媒体查询 - @media")])]),t._v(" "),v("h2",{attrs:{id:"_2-22、常规前端性能优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-22、常规前端性能优化"}},[t._v("#")]),t._v(" 2.22、常规前端性能优化")]),t._v(" "),v("blockquote",[v("p",[t._v("content方面")])]),t._v(" "),v("ul",[v("li",[t._v("减少HTTP请求")]),t._v(" "),v("li",[t._v("减少DNS查询 - DNS缓存")]),t._v(" "),v("li",[t._v("避免重定向 - 多余的中间访问")]),t._v(" "),v("li",[t._v("使用ajax可缓存")]),t._v(" "),v("li",[t._v("非必须组件延迟加载")]),t._v(" "),v("li",[t._v("未来所需组件预加载")]),t._v(" "),v("li",[t._v("减少DOM元素数量")]),t._v(" "),v("li",[t._v("将资源放到不同域下 - 浏览器同时从一个域下载资源的数目有限")]),t._v(" "),v("li",[t._v("避免404")])]),t._v(" "),v("blockquote",[v("p",[t._v("Server方面")])]),t._v(" "),v("ul",[v("li",[t._v("使用CDN")]),t._v(" "),v("li",[t._v("添加Expires或者cache-control响应头")]),t._v(" "),v("li",[t._v("对组件使用gzip压缩")]),t._v(" "),v("li",[t._v("配置etag")]),t._v(" "),v("li",[t._v("ajax使用get进行请求")]),t._v(" "),v("li",[t._v("避免空src的img标签")])]),t._v(" "),v("blockquote",[v("p",[t._v("css方面")])]),t._v(" "),v("ul",[v("li",[t._v("将样式表放到页面顶部")]),t._v(" "),v("li",[t._v("不使用CSS表达式")]),t._v(" "),v("li",[t._v("不使用IE的Filter")])]),t._v(" "),v("blockquote",[v("p",[t._v("javascript方面")])]),t._v(" "),v("ul",[v("li",[t._v("将脚本放到页面底部")]),t._v(" "),v("li",[t._v("将javascript和css从外部引入")]),t._v(" "),v("li",[t._v("压缩javascript和css")]),t._v(" "),v("li",[t._v("删除不要的脚本")]),t._v(" "),v("li",[t._v("减少DOM操作")])])])}),[],!1,null,null,null);_.default=a.exports}}]);